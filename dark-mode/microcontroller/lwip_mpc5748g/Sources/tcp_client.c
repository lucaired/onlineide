#include "lwip/netif.h" /* struct netif, netif_add, netif_set_up, netif_set_default */
#include "lwip/dhcp.h" /* struct dhcp, dhcp_set_struct, dhcp_start */
#include "lwip/tcp.h" /* struct tcp_pcb, tcp_new, tcp_bind, tcp_write, tcp_output, tcp_close, tcp_connect, TCP_WRITE_FLAG_COPY */
#include "lwip/sys.h" /* sys_init; S32DS (linker) will provide port-specific impl. (e.g., `SDK/middleware/tcpip/tcpip_stack/ports/OS/sys_arch.c`) */
#include "lwip/init.h" /* lwip_init */
#include "lwip/timeouts.h" /* sys_check_timeouts */
#include "lwip/ip_addr.h" /* ip_addr_t, ipaddr_aton, ip_addr_set_zero  */

/* device specific driver code */
/* generated by S32DS in `SDK/middleware/tcpip/tcpip_stack/ports/netif/enetif.h` */
#include "enetif.h" /* enet_ethernetif_init, enet_poll_interface, enet_ethernetif_shutdown */

/* globales variables for netifs */
/* THE ethernet interface */
struct netif netif;

/* DHCP struct for the ethernet netif */
extern struct dhcp netif_dhcp;

/* TCP/IP protocol control block */
static struct tcp_pcb *pcb;

/**
 * Set up network interface and start DHCP negotiation for it.
 */
static void enetif_init(void) {
	ip_addr_t ipaddr, netmask, gw;
	err_t err;

	/* fill all IP address structures with zeroes */
#define NETIF_ADDRS &ipaddr, &netmask, &gw,
	ip_addr_set_zero(&gw);
	ip_addr_set_zero(&ipaddr);
	ip_addr_set_zero(&netmask);

	/* add a network interface to the list of lwIP netifs */
	netif_add(&netif, NETIF_ADDRS NULL, enet_ethernetif_init, netif_input);

	/* set a network interface as the default network interface */
	netif_set_default(&netif);

	/* set a statically allocated struct dhcp to work with */
	dhcp_set_struct(&netif, &netif_dhcp);

	/* bring an interface up, available for processing traffic */
	netif_set_up(&netif);

	/* start DHCP negotiation for network interface */
	err = dhcp_start((struct netif *) &netif);
}

static err_t connection_callback(void *arg, struct tcp_pcb *tpcb, err_t err) {
	/* The actual http message*/
	const *message = "GET /api/dark-mode/toggle HTTP/1.0\r\n\r\n";
	u16_t message_len = 43;

	err_t error = tcp_write(tpcb, message, message_len, TCP_WRITE_FLAG_COPY);

	if(error){
		return 1;
	}

	error = tcp_output(tpcb);

	error = tcp_close(tpcb);


	return 0;
}

static void create_tcp_connection() {
	/* Reset the interrupt flag*/
	PINS_DRV_ClearPinExIntFlag(11u);

	ip_addr_t remote_ip;
	ip_addr_t local_ip;

	/* Configure remote port and local port*/
	uint16_t remote_port = 80;
	uint16_t local_port = 0;

	/* Configure ip-address*/
	ipaddr_aton("35.242.243.82", &remote_ip);
	ip_addr_set(&local_ip, &netif.ip_addr);

	pcb = tcp_new();
	tcp_bind(pcb, &local_ip, local_port);

	/* Tcp connection*/
	tcp_connect(pcb, &remote_ip, remote_port, connection_callback);
}

/**
 * Initialize networking and run main program loop.
 */
void start_tcp_client() {

	/* Initialize the interrupthandler with the button that is given in the task and let it call the create_tcp_function*/
	INT_SYS_InstallHandler(SIUL_EIRQ_08_15_IRQn, &create_tcp_connection, NULL);

	INT_SYS_EnableIRQ(SIUL_EIRQ_08_15_IRQn);
	/* init system architecture layer (initialization of timers) */
	sys_init();

	/* init lwIP single-threaded core: initialize the network stack */
	lwip_init();

	/* init network (ethernet) interface */
	enetif_init();

    while(1){

		sys_check_timeouts();

		(void) enet_poll_interface(&netif);

	}

	/* main loop for driver update and timers */
	/* release the network interface */
	enet_ethernetif_shutdown(&netif);
}
